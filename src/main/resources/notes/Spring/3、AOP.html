<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/304720 (zh-CN, DDL); Windows/10.0.14393 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="3225"/>
<h1>3、AOP</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2017/6/14 14:10</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2017/6/14 15:49</i></td></tr>
<tr><td><b>作者：</b></td><td><i>雷丰阳</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div>AOP：（Aspect Oriented Programming）面向切面编程；</div><div>OOP：（Object Oriented Programming ）面向对象编程；</div><div><br/></div><div>面向切面编程：基于OOP基础之上新的编程思想；</div><div>指在程序运行期间，<span style="color: rgb(227, 0, 0);">将某段代码</span><span style="color: rgb(65, 173, 28);">动态的切入</span>到<span style="color: rgb(227, 0, 0);">指定方法</span>的<span style="color: rgb(227, 0, 0);">指定位置</span>进行运行的这种编程方式，面向切面编程；</div><div><br/></div><div>场景：计算器运行计算方法的时候进行日志记录；</div><div>加日志记录：</div><div>1）、直接编写在方法内部；不推荐，修改维护麻烦；</div><div>          </div><div>          日志记录：系统的辅助功能；</div><div>          业务逻辑：（核心功能）</div><div>          耦合；</div><div>2）、我们希望的是；</div><div>          业务逻辑：（核心功能）；日志模块；在核心功能运行期间，自己动态的加上；</div><div>          运行的时候，日志功能可以加上；</div><div>  可以使用动态代理来将日志代码动态的在目标方法执行前后先进行执行；</div><div align="left" style="min-height: 18pt;"><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>package com.atguigu.proxy;</div><div><br/></div><div>import java.lang.reflect.InvocationHandler;</div><div>import java.lang.reflect.Method;</div><div>import java.lang.reflect.Proxy;</div><div>import java.util.Arrays;</div><div><br/></div><div>import com.atguigu.inter.Calculator;</div><div>import com.atguigu.utils.LogUtils;</div><div><br/></div><div>/**</div><div> * 帮Calculator.java生成代理对象的类</div><div> * Object newProxyInstance</div><div> * (ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</div><div> *</div><div> * @author lfy</div><div> *</div><div> */</div><div>public class CalculatorProxy {</div><div><br/></div><div>    /**</div><div>     * 为传入的参数对象创建一个动态代理对象</div><div>     * @param calculator</div><div>     * @return</div><div>     *</div><div>     * Calculator calculator:被代理对象；（宝宝）</div><div>     * 返回的：宋喆</div><div>     */</div><div>    public static Calculator getProxy(final Calculator calculator) {</div><div>        // TODO Auto-generated method stub</div><div><br/></div><div>        //方法执行器。帮我们目标对象执行目标方法</div><div>        InvocationHandler h = new InvocationHandler() {</div><div>            /**</div><div>             * Object proxy：代理对象；给jdk使用，任何时候都不要动这个对象</div><div>             * Method method：当前将要执行的目标对象的方法</div><div>             * Object[] args：这个方法调用时外界传入的参数值</div><div>             */</div><div>            @Override</div><div>            public Object invoke(Object proxy, Method method, Object[] args)</div><div>                    throws Throwable {</div><div>                </div><div>                //System.out.println(&quot;这是动态代理将要帮你执行方法...&quot;);</div><div>                Object result = null;</div><div>                try {</div><div>                    LogUtils.logStart(method, args);</div><div><br/></div><div>                    // 利用反射执行目标方法</div><div>                    //目标方法执行后的返回值</div><div>                    result = method.invoke(calculator, args);</div><div>                    LogUtils.logReturn(method, result);</div><div>                } catch (Exception e) {</div><div>                    LogUtils.logException(method,e);</div><div>                }finally{</div><div>                    LogUtils.logEnd(method);</div><div><br/></div><div>                }</div><div><br/></div><div>                //返回值必须返回出去外界才能拿到真正执行后的返回值</div><div>                return result;</div><div>            }</div><div>        };</div><div>        Class&lt;?&gt;[] interfaces = calculator.getClass().getInterfaces();</div><div>        ClassLoader loader = calculator.getClass().getClassLoader();</div><div><br/></div><div>        //Proxy为目标对象创建代理对象；</div><div>        Object proxy = Proxy.newProxyInstance(loader, interfaces, h);</div><div>        return (Calculator) proxy;</div><div>    }</div><div><br/></div><div>}</div></div><div>动态代理：</div><div>     1）、写起来难；</div><div>     2）、<font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt; background:#e8f2fe"><u>jdk</u></span><span style="font-size:16pt; background:#e8f2fe">默认的动态代理，如果目标对象没有实现任何接口，是无法为他创建代理对象的；</span></font></div></div><div>Spring动态代理难；Spring实现了AOP功能；底层就是动态代理；</div><div>     1）、可以利用Spring一句代码都不写的去创建动态代理；</div><div>               实现简单，而且没有强制要求目标对象必须实现接口；</div><div><span style="color: rgb(227, 0, 0);">将某段代码（日志）</span><span style="color: rgb(65, 173, 28);">动态的切入（不把日志代码写死在业务逻辑方法中）</span>到<span style="color: rgb(227, 0, 0);">指定方法（加减乘除）</span>的<span style="color: rgb(227, 0, 0);">指定位置（方法的开始、结束、异常。。。）</span>进行运行的这种编程方式（Spring简化了面向切面编程）</div><div><br/></div><div><hr/></div><div>AOP专业术语；</div><div><br/></div><div><img src="3、AOP_files/Image.png" type="image/png"/></div><div><br/></div><div><br/></div><div><hr/></div><div>AOP使用步骤：</div><div>1）、导包；</div><div align="left" style="min-height: 18pt;"><div><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">commons</span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">logging</span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">1.1.3.jar</span></font></div></div><div align="left" style="min-height: 18pt;"><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">spring</span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt"><u>aop</u></span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">4.0.0.RELEASE.jar</span></font></div><div align="left" style="min-height: 18pt;"><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">spring</span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">beans</span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">4.0.0.RELEASE.jar</span></font></div><div align="left" style="min-height: 18pt;"><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">spring</span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">context</span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">4.0.0.RELEASE.jar</span></font></div><div align="left" style="min-height: 18pt;"><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">spring</span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">core</span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">4.0.0.RELEASE.jar</span></font></div><div align="left" style="min-height: 18pt;"><div><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">spring</span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">expression</span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">4.0.0.RELEASE.jar</span></font></div><div><span style="font-size: 16pt;"><span style="font-family: Consolas;"><span style="color: rgb(63, 95, 191);"><br/></span></span></span></div><div><span style="font-size: 16pt;"><span style="font-family: Consolas;"><span style="color: rgb(63, 95, 191);">Spring支持面向切面编程的包是：</span></span></span></div><div align="left" style="min-height: 18pt;"><div><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">spring</span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">aspects</span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">4.0.0.RELEASE.jar：基础版</span></font></div></div><div align="left" style="min-height: 18pt;"><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">加强版的面向切面编程（即使目标对象没有实现任何接口也能创建动态代理）</span></font></div><div align="left" style="min-height: 18pt;"><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">com.springsource.net.sf.cglib</span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">2.2.0.jar</span></font></div><div align="left" style="min-height: 18pt;"><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">com.springsource.org.aopalliance</span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">1.0.0.jar</span></font></div><div align="left" style="min-height: 18pt;"><div><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">com.springsource.org.aspectj.weaver</span></font><font color="#7F7F9F" face="Consolas" size="4"><span style="font-size:16pt">-</span></font><font color="#3F5FBF" face="Consolas" size="4"><span style="font-size:16pt">1.6.8.RELEASE.jar</span></font></div></div><div><span style="font-size: 16pt;"><span style="font-family: Consolas;"><span style="color: rgb(63, 95, 191);"><br/></span></span></span></div></div><div>2）、写配置；</div><div>     1）、将目标类和切面类（封装了通知方法（在目标方法执行前后执行的方法））加入到ioc容器中</div><div>     2）、还应该告诉Spring到底哪个是切面类<font color="#646464" face="Consolas" size="4"><span style="font-size:16pt; background:#e8f2fe">@</span><span style="font-size:16pt; background:#d4d4d4">Aspect</span></font></div><div>     3）、告诉Spring，切面类里面的每一个方法，都是何时何地运行；</div><div align="left" style="min-height: 18pt;"><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>@Before(&quot;execution(public int com.atguigu.impl.MyMathCalculator.*(int, int))&quot;)</div><div>    public static void logStart(){</div><div>        System.out.println(&quot;【xxx】方法开始执行，用的参数列表【xxx】&quot;);</div><div>    }</div><div><br/></div><div>    //想在目标方法正常执行完成之后执行</div><div>    @AfterReturning(&quot;execution(public int com.atguigu.impl.MyMathCalculator.*(int, int))&quot;)</div><div>    public static void logReturn(){</div><div>        System.out.println(&quot;【xxxx】方法正常执行完成，计算结果是：&quot;);</div><div>    }</div><div><br/></div><div>    //想在目标方法出现异常的时候执行</div><div>    @AfterThrowing(&quot;execution(public int com.atguigu.impl.MyMathCalculator.*(int, int))&quot;)</div><div>    public static void logException() {</div><div>        System.out.println(&quot;【xxxx】方法执行出现异常了，异常信息是：；这个异常已经通知测试小组进行排查&quot;);</div><div>    }</div><div><br/></div><div>    //想在目标方法结束的时候执行</div><div>    @After(&quot;execution(public int com.atguigu.impl.MyMathCalculator.*(int, int))&quot;)</div><div>    public static void logEnd() {</div><div>        System.out.println(&quot;【xxx】方法最终结束了&quot;);</div><div>    }</div></div><div>          4）、开启基于注解的AOP模式</div></div><div><br/></div><div>3）、测试；</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><br/></div><div>Calculator bean = ioc.getBean(Calculator.class);</div><div>        bean.add(2, 1);</div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>          </div><div><br/></div><div><br/></div></span>
</div></body></html> 